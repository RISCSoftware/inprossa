import json
import re
import sys
import traceback
from collections import Counter

from sentence_transformers import util

import constants
from sentence_transformers import *

from Translator.Objects.MiniZincTranslator import MiniZincTranslator
from constants import SYSTEM_PROMPT_FOLDER, DEBUG_MODE_ON
import logging
logger = logging.getLogger(__name__)

USE_OPTDSL = constants.USE_OPTDSL
CHOSEN_LANGUAGE = constants.CHOSEN_LANGUAGE

class Tree:
    def __init__(self):
        self.root = TreeNode("root")

class TreeNode:
    MAX_LEVEL = 4
    MAX_CANDIDATES = 4

    def __init__(self, name = "", parent = None, level: int = 0):
        self.name = name
        self.content = f"# -- {self.name} --\n"
        self.parent = parent
        self.children = []
        self.is_terminal = False
        self.level = level
        self.visits = 0  # Visit count
        self.wins = 0  # Win count
        #self.untried_candidates = self.get_candidates()
        self.partial_formulation_up_until_now = build_code(self)

    def get_partial_formulation_up_until_now(self):
        return self.partial_formulation_up_until_now

    def set_content(self, content):
        content = remove_programming_environment(content)
        if constants.USE_ALL_AT_ONCE_AND_EXTRACT: content = remove_duplicate_lines(build_code(self), content)
        self.content += "\n\n" + content.strip()
        self.partial_formulation_up_until_now = build_code(self)

    def prepend_section_title(self, block):
        return f"# --- {self.name} ---\n" + block
'''
    def add_child(self, child):
        self.children.append(child)

    def is_terminal(self):
        return self.level == self.MAX_LEVEL

    def get_candidates(self):
        """Candidates generated by LLM."""
        return ["LLM" for i in range(self.MAX_CANDIDATES)]

    def is_fully_expanded(self):
        return len(self.children) >= self.MAX_CANDIDATES

    def expand(self):
        """Add one of the remaining actions as a child."""
        action = self.untried_candidates.pop()
        if action == "LLM":
            # Prompt LLM
            child = TreeNode(parent=self, llm1=self.llm1)
        else:
            raise ValueError("Invalid action.")
        self.children.append(child)
        return child

    def best_child(self, c=1.4):
        """Select child with best UCB1 score."""
        return max(self.children, key=lambda child:
        (child.wins / child.visits) +
        c * math.sqrt(math.log(self.visits) / child.visits))

    def rollout(self):
        """Propose random candidates until MAX_LEVEL is reached."""
        cur_node = self

        while True:
            if cur_node.is_terminal:
                return self.reward_func(cur_node)

            actions = self.get_candidates()
            #if not actions: return 0.5  # Draw

            move = random.choice(actions)
            cur_node.add_child(move)
            cur_node = move

    def reward_func(self, state):
        """Calculate reward terminal value"""
        return 0

    def backpropagate(self, result):
        """Update stats up the tree."""
        self.visits += 1
        self.wins += result
        if self.parent:
            self.parent.backpropagate(result)
'''

class RootNode(TreeNode):
    def __init__(self, name = "", parent = None, ):
        super().__init__(name, parent)

    def set_content(self, content):
        if "--- Objects ---".lower() not in content.lower() or "--- Constants ---".lower() not in content.lower() or "--- Decision variables ---".lower() not in content.lower() or "--- Objective function ---".lower() not in content.lower() or "--- Constraints ---".lower() not in content.lower():
            return False
        blocks = {}
        current_key = None

        for line in content.splitlines():
            # Detect a block header, e.g. "--- Datatypes ---"
            m = re.match(r'^---\s*(.+?)\s*---$', line)
            if m:
                current_key = m.group(1).strip().lower()  # use lower case key
                blocks[current_key] = []
            else:
                if current_key is not None:
                    blocks[current_key].append(line)

        # Convert lists into single strings
        for k in blocks:
            blocks[k] = "\n".join(blocks[k]).strip()

        self.content = blocks
        return True

class ObjectsNode(TreeNode):
    def __init__(self, name = "", parent = None):
        super().__init__("Objects", parent, level=1)

    def get_textual_repr(self):
        return self.parent.content()

class VariablesConstantsNode(TreeNode):
    def __init__(self, name = "", parent = None):
        self.variables_and_constants = []
        super().__init__("Constants", parent, level=2)

    def set_constants(self, incomming_constants):
        if not is_valid_json(incomming_constants):
            return False
        if not constants.USE_ALL_AT_ONCE_AND_EXTRACT:
            # Filter constants
            filtered_constants_only = [item for item in json.loads(incomming_constants) if item.get("variable_name", "").isupper()]
            # TODO add sanity check, nr of input parameter == len(filtered_constants_only)
            # Safety check: There must be at least one constant (input)
            if len(filtered_constants_only) == 0:
                if constants.DEBUG_MODE_ON: print(f"Checking node created for level 2 (constants): No uppercase constants found.")
                return False
            self.variables_and_constants.extend(remove_duplicate_variables(filtered_constants_only))
            self.content = self.get_as_codeblock()
        else:
            self.content += incomming_constants
        self.partial_formulation_up_until_now = build_code(self)
        return True

    def set_variables(self, variables):
        if not is_valid_json(variables):
            return False
        if not constants.USE_ALL_AT_ONCE_AND_EXTRACT:
            # Filter decision variables
            filtered_decision_variables_only = [item for item in json.loads(variables) if item.get("variable_name", "").islower()]

            # Safety check: There must be at least one decision variable (output)
            if len(filtered_decision_variables_only) == 0:
                if constants.DEBUG_MODE_ON: print(
                    f"Checking node created for level 3 (decision variables): No lower case variables found.")
                return False
            self.variables_and_constants.extend(remove_duplicate_variables(filtered_decision_variables_only))
            self.define_list_lengths()
            self.content = f"\n\n# --- {self.name} ---\n" + self.get_as_codeblock()
        else:
            self.content += "\n\n" + variables
        self.partial_formulation_up_until_now = build_code(self)
        return True

    def define_list_lengths(self):
        for constant in self.variables_and_constants:
            if "DSList" in constant["type"]:
                match = re.search(r"length=(\d+)", constant["type"])
                if match:
                    length_value = int(match.group(1))
                    self.variables_and_constants.append(
                        {
                            "description": f"Length of {constant["variable_name"]}",
                            "variable_name": f"N_{constant["variable_name"]}",
                            "type": "int",
                            "initialization": f"N_{constant["variable_name"]} : int = {length_value}"
                        }
                    )
                else:
                    if DEBUG_MODE_ON: print("Warning: DSList has no length defined.")

    def prepend_section_title(self, block):
        if self.content == "":
            return f"# --- {self.name} ---\n" + block
        else:
            return f"# --- Decision variables ---\n" + block

    def get_as_codeblock(self):
        variable_block = ""
        encountered_decision_variables = False
        for definition in self.variables_and_constants:
            if definition["variable_name"].islower() and encountered_decision_variables:
                variable_block += f"\n\n# --- Decision variables ---\n"
                encountered_decision_variables = True
            variable_block += f"{definition["initialization"]}\n"
        return variable_block

class ObjectiveNode(TreeNode):
    def __init__(self, name = "", parent = None):
        super().__init__("Objective", parent, level=3)

class ConstraintsNode(TreeNode):
    def __init__(self, name = "", parent = None):
        super().__init__("Constraints", parent, level=4)
        self.is_terminal = True

def is_valid_json(s: str) -> bool:
    try:
        json.loads(s)
        return True
    except ValueError:
        return False

def extract_assigments(text):
    pattern = re.compile(
        r'^\s*([^=#\s][^=]*)\s*=\s*([^#]+?)\s*(?:#.*)?$',
        flags=re.MULTILINE
    )
    variable_block = ""
    for m in pattern.finditer(text):
        left = m.group(1).strip()
        right = m.group(2).strip()
        variable_block += f"{left} = {right}\n"

def build_code(node):
    if node is None or node.level == 0:
        return ""

    return build_code(node.parent) + "\n\n" + node.content

def check_executability(node, raw_code : str):
    # Construct partial/full formulation up until now, depending on current level
    if USE_OPTDSL:
        variable_block = f"\n{node.get_partial_formulation_up_until_now()}\n"
    else:
        variable_block = f"from z3 import * \n{node.get_partial_formulation_up_until_now()}\n"

    num_lines_without_raw_code = len(variable_block.splitlines())
    # Prepare raw constants/variable definitions and add to partial formulation (up until now)
    if not constants.USE_ALL_AT_ONCE_AND_EXTRACT and node.level == 2:
        raw_code = json.loads(raw_code)
        if not isinstance(raw_code, list):
            return """Error, invalid type of definitions. Must be a array of json objects.
The response must exactly adhere to the following format, no outer wrappers:
Return you answer in the following format:
[{
     "description":<description>,
     "variable_name":<variable_name>,
     "type":<variable_type>,
     "initialization":<initialization>
}]
The structure must fulfill following requirements:
1. <description> is a placeholder for a compact, concise description of the variable.
2. <variable_name> is the unique variable identifier described in description, that will later be used for creating decision variables and constraints. Constants naming convention: capital letters only.
3. <initialization> is the OptDSL variable declaration and initialization code block, fully with assignments, of the variable in variable field. Must be valid OptDSL code.
4. <variable_type> is the type of the variable. The variable type is either an object, a primitive python type (e.g. int, float) or an inlined DSList declaration. It can be found in the initialization after the double colon as the type of the variable.
5. No additional properties allowed.
"""
        # Remove upper or lower case for constants and variables respectively
        if len(node.variables_and_constants) == 0:
            raw_code = [item for item in raw_code if
                        item.get("variable_name", "").isupper()]
        else:
            raw_code = [item for item in raw_code if
                        item.get("variable_name", "").islower()]
        if raw_code == "": return "Error - Invalid result: Result is empty."
        for definition in raw_code:
            # Safety check: check if right hand side is json code
            if "[{" in str(definition["initialization"]):
                return f"Error: {definition["initialization"]}\ninitialization of equation is not valid {CHOSEN_LANGUAGE} code. Invalid type, must not be json or dict."
            variable_block += f"{definition["initialization"]}\n"
    elif not constants.USE_ALL_AT_ONCE_AND_EXTRACT:
    # Prepare raw obj. function or constraints and add to partial formulation (up until now)
        # Safety check: no json has be returned instead of code
        if is_valid_json(raw_code) or raw_code.startswith("{") or raw_code.startswith("["):
            return f"Error: Result must not be json objects, valid {constants.CHOSEN_LANGUAGE} code."

        raw_code = remove_programming_environment(raw_code)

        # Safety check: no json has be returned instead of code
        if is_valid_json(raw_code) or raw_code.startswith("{") or raw_code.startswith("["):
            return f"""Error: Result must not be json objects, valid {constants.CHOSEN_LANGUAGE} code.
The response must exactly adhere to the following format, no outer wrappers:
Return you answer in the following format:
[{{
    "description":<description>,
    "variable_name":<variable_name>,
    "type":<variable_type>,
    "initialization":<initialization>
}}]
The structure must fulfill following requirements:
1. <description> is a placeholder for a compact, concise description of the variable.
2. <variable_name> is the unique variable identifier described in description, that will later be used for creating decision variables and constraints. Constants naming convention: capital letters only.
3. <initialization> is the OptDSL variable declaration and initialization code block, fully with assignments, of the variable in variable field. Must be valid OptDSL code.
4. <variable_type> is the type of the variable. The variable type is either an object, a primitive python type (e.g. int, float) or an inlined DSList declaration. It can be found in the initialization after the double colon as the type of the variable.
5. No additional properties allowed."""

        # Result must not be empty
        if raw_code == "": return "Error - Invalid result: Result is empty."

        variable_block += raw_code
    else:
        variable_block += raw_code

    # Execute code block of partial/full formulation
    try:
        if USE_OPTDSL:
            code_obj = compile(variable_block, "<string>", "exec")
            model = MiniZincTranslator(variable_block).unroll_translation()
        else:
            exec(variable_block, {})
    except SyntaxError as e:
        return f"Syntaxerror \"{e.msg}\" in line {e.lineno}, at offset {e.offset}: {e.text.rstrip() if e.text else None}"
    except Exception as e:
        logger.exception(e)
        if "unexpected indent" in str(e):
            return f"Constraints/Objective FormatError"
        exc_type, exc_value, exc_tb = sys.exc_info()
        stack_trace_str = ''.join(traceback.format_exception(exc_type, exc_value, exc_tb))
        # Filter error for z3
        m = re.search(r'(?s).*?(File\s+"<string>",\s*line\s*\d+)(?!.*File\s+"<string>",\s*line\s*\d+)', stack_trace_str)
        error_message = str(e)
        if m:
            m = re.search(r'File\s+"<string>",\s*line\s*(\d+)', m.group(1))
            line_no = int(m.group(1))
            lines = variable_block.splitlines()
            line_with_error = lines[line_no-1]
            return f"{error_message} in line {line_no}: {line_with_error}\n"
        # Filter error from optdsl-translator
        m = re.search(r"(?m)^(?P<type>[\w\.]+(?:Error|Exception)):\s*(?P<msg>.*)$", stack_trace_str)
        if m:
            exc_type = m.group("type")
            exc_msg = m.group("msg")
            if exc_msg == 'Unknown type string: DSList':
                return f"Error: Variable object type definition must adhere to the EBNF grammar \"DSList\" \"(\" FunArgs([\"length\", \"elem_type\"]) \")\"."
            elif exc_msg == 'Unknown type string: DSInt':
                return f"Error: Variable object type definition must adhere to the EBNF grammar \"DSInt\" \"(\" FunArgs([\"lb\", \"ub\"]) \")\"."
            elif exc_msg == 'Unknown type string: DSFloat':
                return f"Error: Variable object type definition must not have type DSFloat, but must adhere to the EBNF grammar \"DSFloat\" \"(\" FunArgs([\"lb\", \"ub\"]) \")\"."
            elif exc_msg == 'Unknown type string: DSBool':
                return f"Error: Variable object type definition must not have type DSBool, but must adhere to the EBNF grammar \"DSBool\" \"(\" \")\"."
            elif exc_msg == 'Unknown type string: DSRecord':
                return f"Error: Variable object type definition must not have type DSRecord, but must adhere to the EBNF grammar \"DSRecord\" \"(\" \"{{\" RecordField (\",\" RecordField)* \"}}\" \")\"."
            elif exc_msg == "'int' object is not subscriptable":
                return f"Error: Do not perform calculations within index brackets. Instead, calculate it as temporary variable and then use it for accessing the list index."
            elif "attr='append', ctx=Load())," in exc_msg:
                return f"Error - Do not use function calls append() and extend() for DSList."
            return f"{exc_type} - {exc_msg}, occurring at: {error_message.replace("Error processing statement: ", "")}\n"

        return str(e)
    return None

def remove_programming_environment(raw_response: str, node = None) -> str:
    # Remove any line that starts with "from z3" (even with leading spaces)
    cleaned = re.sub(r'^\s*from z3.*$', '', raw_response, flags=re.MULTILINE)

    cleaned = cleaned.replace("OptDSL", "")
    cleaned = cleaned.replace("json", "")
    cleaned = cleaned.replace("´´´python", "")
    cleaned = cleaned.replace("´´´", "")
    cleaned = cleaned.replace("```python", "")
    cleaned = cleaned.replace("```", "")
    cleaned = re.sub(r"<reasoning>.*?</reasoning>", "", cleaned, flags=re.DOTALL)

    # Remove already existing code
    #if node is not None: cleaned = remove_duplicate_lines(build_code(node), cleaned)
    return cleaned

model = SentenceTransformer("all-MiniLM-L6-v2")
def remove_duplicate_variables(variable_definitions):
    filtered_out_duplicates = []
    for i in range(len(variable_definitions)):
        found_duplicate = False
        for j in range(i + 1, len(variable_definitions)):
            emb1 = model.encode(variable_definitions[i]["variable_name"], convert_to_tensor=True)
            emb2 = model.encode(variable_definitions[j]["variable_name"], convert_to_tensor=True)
            if util.cos_sim(emb1, emb2) > 0.89:
                found_duplicate = True
        if not found_duplicate:
            filtered_out_duplicates.append(variable_definitions[i])
        else:
            if constants.DEBUG_MODE_ON: print(f"Duplicate variables detected: {variable_definitions[i]} - {variable_definitions[j]}")
    return filtered_out_duplicates

def load_sp_file(file_path):
    file_path = SYSTEM_PROMPT_FOLDER + file_path
    with open(file_path, "r", encoding="utf-8") as f:
        return f.read()

def find_function_names(code_str):
    pattern = r'^\s*def\s+([A-Za-z_][A-Za-z0-9_]*)\s*\('
    names = re.findall(pattern, code_str, flags=re.MULTILINE)
    return names

def check_functions_appear_twice(code_str):
    names = find_function_names(code_str)
    appears_less_than_twice = []
    for name in names:
        if len(re.findall(r'\b' + re.escape(names[0]) + r'\b', code_str)) <= 1:
            appears_less_than_twice.append(name)
    return appears_less_than_twice

def remove_duplicate_lines(variable_block: str, raw_code: str):
    # Split each string into lines (preserving distinct lines)
    lines1 = variable_block.splitlines()
    lines2 = raw_code.splitlines()

    # Use sets to find which lines are common
    set1 = set(lines1)
    set2 = set(lines2)
    common = set1.intersection(set2)

    # If you want to preserve original order (from str1) of the common lines:
    return "\n".join([line for line in lines2 if line not in common])

def prepare_constraints_for_insertion(node, code: str):
    decomposed = decompose_full_definition(code)
    prepared_constraints = ""
    for key in decomposed.keys():
        prepared_constraints += f"# -- {key} --\n{decomposed[key]}"

def decompose_full_definition (full_definition: str):
    if ("# --- Objects ---".lower() in full_definition.lower() or
           "# --- Constants ---".lower() in full_definition.lower() or
           "# --- Objective ---".lower() in full_definition.lower() or
           "# --- Decision variables ---".lower() in full_definition.lower() or
           "# --- Constraints ---".lower() in full_definition.lower() or
           "# --- Incorrect Code ---".lower() in full_definition.lower()):
        full_definition = remove_programming_environment(full_definition)
        blocks = {}
        current_key = None
        temp = []

        for line in full_definition.splitlines():
            # Detect a block header, e.g. "--- Datatypes ---"
            m = re.match(r'^# ---\s*(.+?)\s*---$', line)
            if m:
                current_key = m.group(1).strip().lower()  # use lower case key
                blocks[current_key] = []
            else:
                if current_key is not None:
                    if len(temp) > 0:
                        blocks[current_key] = temp + blocks[current_key]
                        temp = []
                    blocks[current_key].append(line)
                else:
                    if len(line) > 0: temp.append(line)

        # Convert lists into single strings
        for k in blocks:
            blocks[k] = "\n".join(blocks[k]).strip()
        return blocks
    return None
