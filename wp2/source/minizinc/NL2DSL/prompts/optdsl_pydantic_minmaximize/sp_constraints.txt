Extend the given OptDSL python code snippet, with diverse, optimal and consistent constraints exactly according to the given subproblem as OptDSL python code. Define nothing else. The constraints are given as \"sub problem definitions\"."
    Your priority is to define diverse, efficient and optimal assert-constraints which must exactly represent the subproblem description, nothing else. Do not comment the code within functions.
    The resulting encoding must produce an optimal objective value when given to a solver. Do not encode identical constraints multiple times. Prioritize diversity, consistency and correctness of results. Do not return the same encoding twice.
    1. Use given datatypes, constants and decision variables in the given python snippet, nothing else. Define all variables consistently.
    2. The result must be minimal and semantically concise to the given subproblem part. Define exactly one single function containing the constraints for exactly the given subproblem and for setting all fields of variables with the same redundant fields equal (see rule 17), nothing else. Do not call "return None". Do not call "return" without any names or tuples.
    3. Do not repeat already present definitions. Add non-redundant streamliners. If a variable already has lower and/or upper bounds by Field.pydantic, then do not define the same bounding streamliners/constraints for that variable. Do not add redundant constraints.
    4. Add minimal necessary auxiliary variables, that are not defined yet. Give precedence to inlining list accesses instead of creating an auxiliary variable for it.
    5. Define a type, int, float, object type defined with double colon, for all auxiliary variables at root and within functions. Decision variables and auxiliary variables at root must be defined as input parameter, if used within a function. Temporary variables and temporary variables of an object type must be declared with that object type, also within functions.
    6. Do not assign and-, or- and comparison-expressions to a temporary variable, but combine them into an assert-expression. If calculations are required within the assert-expression, do not extract them into temporary variables. It is forbidden to extract single object fields into a temporary variable.
    ´´´
    # Example for random car object, learn from it
    total_tires: int = car.standard_tires + car.extra_tires
    c : int = car.tire_capacity
    assert total_tires > c # invalid
    assert car.standard_tires + car.extra_tires > car.tire_capacity # valid
    assert car.standard_tires + car.extra_tires < 20 # valid
    ´´´
    7. After each function definition, immediately call that function with the correct input parameters. Define parameter names within function as lower case.
    8. Each defined function must be called exactly once. The respective function must have a name that reflects the subproblem it encodes.
    9. Do not use any import or functions or variables from other packages, except for pydantic and typing. Do not use None.
    10. Make sure to open and close brackets correctly.
    11. Do not come up with any examples and do not use placeholders.
    12. The result must be compilable python OptDSL code.
    13. Use the EBNF grammar of OptDSL in the system prompt. Equality, inequality and relation expressions can not be assigned to a temporary variable.
    14. Make sure the parameter list types in the function definition adhere to the EBNF grammar in the system prompt (e.g.  def some_func (constant: float, dec_var: Annotated[<type>, Field(<optional_properties>)]): ).
    15. Do not use the function len(), instead define the required array length manually with a hard coded correct number.
    16. Encode exactly the subproblem with sensible upper and lower bounds, nothing else. If you initialize a typing.Annotated with pydantic.Field of type int or float, then set it at least to lower bound and at most to upper bound.
    17. At the end always set all fields of two different variables with the same redundant fields, equal. Define it once in the whole formulation.
    ´´´
    # Example for point 17.
    Car = DSRecord({
        "licence_plate": DSFloat(),
        "nr_of_seats": DSInt(lb=1, ub=10)
    })
    licence_plate_numbers : DSList(length=50, elem_type=DSRecord)
    nr_of_seats_per_car : DSList(length=50, elem_type=DSRecord)
    # Necessary equality constraints due to redundancies in variable fields
    for i in (1, 51):
        assert licence_plate_numbers[i].nr_of_seats = nr_of_seats_per_car[i].nr_of_seats
        assert nr_of_seats_per_car[i].licence_plate = licence_plate_numbers[i].licence_plate
    ´´´

Return you answer in the following format:
´´´python
# --- Auxiliary Variables ---
# Leave empty, if not required.

# --- Constraints ---
<solution>
´´´ replace <solution> with the code. <solution> must not be empty.
