OptDSL is a python-like (pythonic) high-level constraint modelling language for formulizing optimization problems diversely and optimally in a programmatical fashion. Eventually, OptDSL is translated into Minizinc. 10. If you encountered a similar problem before, provide a diverse formulation while being syntactically valid.
1.	OptDSL is python where constants have python native primitive types int, float. For strings do not use str, but float. Decision variables must be of primitive type DSInt(), DSFloat() or DSBool(), or of complex type list as typing.Annotated or DSRecord.
2.  For DSInt set sensible lower (lb) and upper bound (ub) for DSInt(lb=<>,ub=<>). If you initialize DSInt-variables, set them at least lower bound and at most with upper bound.
3.  Object type creation with DSRecord and initialization of a variable with an object type must be two separate steps. For object type creation and variable initialization, each attribute needs to be explicitly set manually with accessing each attribute or initializing it as dict or json.
4.  Object fields may be accessed and used in asserts. Object fields can not be assigned a value.
5.  All variables must define a type, <variable_name> : <type>. Possible types are e.g. int, float, list or object types.
6.	Indices in a list start at 1, not 0. Consequently, when iterating with a variable through a list we need, LIST_LEN = <length of list> + 1 for i in range(1, LIST_LEN) for a list in typing.Annotated.
7.  List as typing.Annotated is a fixed-size list, in the form of "list_x : Annotated[list[<element_type>], Len(<list_length>, <list_length>)]". No list comprehension allowed. For the field elem_type do not inline DSRecords, but use defined object types. But do not inline other DS types (e.g. DSInt(), DSFloat(), DSBool()). List as typing.Annotated does not support functions append() and extend().
8.  Do not use Python's len(), max() or min() functions. Do not use continue and break statements. Variables must not be of type "dict" or set. For loops with range() only use constants and integers.
9.	Constraints are defined within a python function. Define input parameter. There must at least be one input parameter. Define all decision variables and auxiliary variables, that are required for constraint formulation and are defined at root, as input parameters. Constants (variables in capital letters) can be accessed everywhere and do not have to be given as input parameter. Only returning names or tuple of names is supported.
10.	After each function definition, immediately call that function with the correct input parameters.
11.	Constraints are defined as asserts, like in a test. For constraint definition use equality, inequality and relation expressions. Make use of the python-built-in function any() and all() in combination with assert. Equality, inequality and relation expressions may only be used within assert, not outside.
12.	Allowed operators for assert-constraints: all, any, >=, <=, ==, !=, <, >, or, and, not. No other operators are allowed. Use brackets for nested operations.

OptDSL adheres to following EBNF grammar (extended backus-naur form):
-------------------
Block := Statement*
Statement := ConstDecl | VarDecl | FunDef | SimpleStmt

# Top-level type declarations
DSTypeExp := DSIntType | DSFloatType | DSBoolType | DSListType | DSRecordType
ArgumentList := ID*
FunArg([]) := # Nothing
FunArgs(First :: Rest) := # [ID1, ID2, ID3, ...,  IDn] := ID1 :: [ID2, ID3, ...,  IDn]
    Expr, FunArgs(Rest) |
    First "=" Expr, NamedFunArgs(Rest) |
    NamedFunArgs(Rest)
NamedFunArgs(First :: Rest) :=
    First "=" Expr, NamedFunArgs(Rest) |
    NamedFunArgs(Rest)
DSIntType := "DSInt" "(" FunArgs(["lb", "ub"]) ")"
DSFloatType := "DSFloat" "(" FunArgs(["lb", "ub"]) ")"
DSBoolType := "DSBool" "(" ")"
DSListType := "Annotated" "[" "list" "[" ListTypeRef "]," "Len" "(" INT "," INT ")" "]"
DSRecordType := "DSRecord" "(" "{" RecordField ("," RecordField)* "}" ")"
RecordField := STR ":" TypeRef
ListTypeRef := "int" | "float" | "bool"
TypeRef := "int" | "float" | "bool" | ID | DSTypeExp

# Constants
ConstDecl := UPPER_ID ":" TypeRef "=" ConstExpr
ConstExpr := Literal | ListLiteral | RecordLiteral | ID
ListLiteral := "[" ConstExpr? "]"
RecordLiteral := "{" RecordFieldLiteral ("," RecordFieldLiteral)* "}"
RecordFieldLiteral := STR ":" ConstExpr

# Variables and assignments
VarDecl := ID ":" TypeRef ("=" Expr)?

# Functions
FunDef := "def" ID "(" ParamList? ")" ":" Block
ParamList := Param ("," Param)*
Param := ID ":" TypeRef ("=" Expr)?
FunCall := ID "(" ArgList? ")"
ArgList := (Arg ("," Arg)*)?
Arg := (ID "=")? Expr

# Simple statements in blocks
SimpleStmt := AssignStmt
    | AssertStmt
    | ForStmt
    | IfStmt
    | ReturnStmt
AssignStmt := Target "=" Expr // covers x=â€¦, a[i]=â€¦, obj.f=â€¦
Target := ID
    | Target "." ID
    | Target "[" Expr "]"
    | "objective"
AssertStmt := "assert" ComparisionExpr
ReturnStmt := "return" Expr

Control flow
ForStmt := "for" ID "in" Iterable ":" Block
| "for" ID "," ID "in" "enumerate" "(" Iterable ")" ":" Block
Iterable := ID | ListLiteral | "range" "(" RangeExpr "," RangeExpr ")"
IfStmt := "if" (ComparisionExpr | Expr) ":" Block ElseClause?
ElseClause := "else" ":" Block

Expressions
Exps := Expr ("," Expr)*
Expr := ID
| Literal # No variables inside
| ListLiteral
| RecordLiteral
| FunCall
| "(" Expr ")" # to give priorities
| Expr ArithmeticBinOp Expr
| UnOp Expr
| "objective" ArithmeticBinOp Expr
ComparisionExpr := Expr RelationBinOp Expr
| Expr LogicalBinOp Expr
| ComparisionExpr RelationBinOp ComparisionExpr
| ComparisionExpr LogicalBinOp ComparisionExpr
| UnOp Expr
RangeExpr := UPPER_ID
| INT
| RangeExpr ArithmeticBinOp RangeExpr
Literal := INT | FLOAT | "True" | "False"
BinOp := ArithmeticBinOp
| RelationBinOp
| LogicalBinOp
ArithmeticBinOp := "+" | "-" | "*" | "/" | "%"
RelationBinOp := "==" | "!=" | "<" | "<=" | ">" | ">="
LogicalBinOp := "and" | "or"
UnOp := "-" | "not"

Lexical / structural conventions
ID: Python identifier.
UPPER_ID: identifier in all caps (and _), used for constants.
INT: integer literal.
FLOAT: floating-point literal.
STR: quoted string literal.
-------------------

In-context learning full translation example for OptDSL - START
-------------------
Global problem:
Prompt:
´´´ json
{
    "input" = {
        "MAX_ALLOWED_WEIGHT": 110,
        "ITEMS": [
            {
                "name": "item1"
                "value": 15,
                "weight": 12
            },
            {
                "name": "item2",
                "value": 50,
                "weight": 70
            },
            {
                "name": "item3",
                "value": 80,
                "weight": 100
            },
            {
                "name": "item4",
                "value": 80,
                "weight": 20
            },
            {
                "name": "item5",
                "value": 20,
                "weight": 12
            },
            {
                "name": "item6",
                "value": 25,
                "weight": 5
            }
        ]
    },
    "output": [
        {
            "description": "Chosen Items",
            "mandatory_variable_name": "chosen_items",
            "suggested_shape": "boolean array"
        },
        {
            "description": "Accumulated Value, which is the objective to maximize"
            "mandatory_variable_name": "accumulated_value",
            "suggested_shape": "integer"
        }
    ]
}
´´´
Global problem description:
This problem involves a collection of items, where each have a value and a weight. The goal is to decide which items are chosen to put into a schoolbag that a maximal accumulated value is achieved.

Sub problem description - items that go in the bag:
In the bag only go items from the given collection, such that the cumulative weight of all chosen items must never exceed the maximum allowed weight of 110.
At the same time, we want to achieve a maximum of accumulated item value. One or more items are chosen and put into the schoolbag. The result are the chosen items.


Expected result:
´´´ python
# --- Objects ---
Item = DSRecord({
    "value": int,
    "weight": DSInt()
})

# --- Constants ---
ITEM1 : Item = {"value": 15, "weight": 12}
ITEM2 : Item = {"value": 50, "weight": 70}
ITEM3 : Item
ITEM3.value = 80
ITEM3.weight = 100
ITEM4 : Item
ITEM4.value = 80
ITEM4.weight = 20
ITEM5 : Item
ITEM5.value = 20
ITEM5.weight = 12
ITEM6 : Item
ITEM6.value = 25
ITEM6.weight = 5
ITEMS : Annotated[list[Item], Len(6, 6)] = [ITEM1, ITEM2, ITEM3, ITEM4, ITEM5, ITEM6]
N_ITEMS : int = 6
MAX_WEIGHT : int = 110

# --- Decision Variables ---
chosen_items : Annotated[list[bool], Len(6, 6)]

# --- Constraints ---
def pack_item(items: Items, chosen_items: Annotated[list[bool], Len(6, 6)]:
    accumulated_weight = 0
    objective: int = 0
    for i in range(1, N_ITEMS + 1):
        if chosen_items[i]:
            item : Item = items[i]
            accumulated_weight = accumulated_weight + item.weight
            objective = objective - item.value
    return accumulated_weight

accumulated_weight = pack_item(ITEMS, chosen_items)

assert accumulated_weight > 0
assert accumulated_weight < MAX_WEIGHT
´´´
-------------------
In-context learning full translation example for OptDSL - END